/*
 * babeltrace.i.in
 *
 * Babeltrace Python Module interface file
 *
 * Copyright 2012 EfficiOS Inc.
 *
 * Author: Danny Serres <danny.serres@efficios.com>
 * Author: Jérémie Galarneau <jeremie.galarneau@efficios.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 */


%define DOCSTRING
"BABELTRACE_VERSION_STR

Babeltrace  is a trace viewer and converter reading and writing the
Common Trace Format (CTF). Its main use is to pretty-print CTF
traces into a human-readable text output.

To use this module, the first step is to create a TraceCollection and add a
trace to it."
%enddef

%module(docstring=DOCSTRING) babeltrace

%include "typemaps.i"
%{
#define SWIG_FILE_WITH_INIT
#include <babeltrace/babeltrace.h>
#include <babeltrace/babeltrace-internal.h>
#include <babeltrace/trace-handle.h>
#include <babeltrace/trace-handle-internal.h>
#include <babeltrace/context.h>
#include <babeltrace/context-internal.h>
#include <babeltrace/iterator.h>
#include <babeltrace/iterator-internal.h>
#include <babeltrace/format.h>
#include <babeltrace/list.h>
#include <babeltrace/types.h>
#include <babeltrace/ctf/iterator.h>
#include "python-complements.h"
#include <babeltrace/ctf-writer/clock.h>
#include <babeltrace/ctf-writer/event-fields.h>
#include <babeltrace/ctf-writer/event-types.h>
#include <babeltrace/ctf-writer/event.h>
#include <babeltrace/ctf-writer/stream.h>
#include <babeltrace/ctf-writer/writer.h>
%}

typedef unsigned long long uint64_t;
typedef long long int64_t;
typedef int bt_intern_str;
typedef int64_t ssize_t;

/* =================================================================
		PYTHON-COMPLEMENTS.H
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*/

FILE *_bt_file_open(char *file_path, char *mode);
void _bt_file_close(FILE *fp);
struct bt_definition **_bt_python_field_listcaller(
		const struct bt_ctf_event *ctf_event,
		const struct bt_definition *scope,
		unsigned int *OUTPUT);
struct bt_definition *_bt_python_field_one_from_list(
		struct bt_definition **list, int index);
struct bt_ctf_event_decl **_bt_python_event_decl_listcaller(
		int handle_id,
		struct bt_context *ctx,
		unsigned int *OUTPUT);
struct bt_ctf_event_decl *_bt_python_decl_one_from_list(
		struct bt_ctf_event_decl **list, int index);
struct bt_ctf_field_decl **_by_python_field_decl_listcaller(
		struct bt_ctf_event_decl *event_decl,
		enum bt_ctf_scope scope,
		unsigned int *OUTPUT);
struct bt_ctf_field_decl *_bt_python_field_decl_one_from_list(
		struct bt_ctf_field_decl **list, int index);
struct definition_array *_bt_python_get_array_from_def(
		struct bt_definition *field);
struct definition_sequence *_bt_python_get_sequence_from_def(
		struct bt_definition *field);
struct bt_declaration *_bt_python_get_array_element_declaration(
		struct bt_declaration *field);
struct bt_declaration *_bt_python_get_sequence_element_declaration(
		struct bt_declaration *field);
const char *_bt_python_get_array_string(struct bt_definition *field);
const char *_bt_python_get_sequence_string(struct bt_definition *field);
int _bt_python_field_integer_get_signedness(const struct bt_ctf_field *field);
enum ctf_type_id _bt_python_get_field_type(const struct bt_ctf_field *field);
struct bt_iter_pos *_bt_python_create_iter_pos(void);

/* =================================================================
		CONTEXT.H, CONTEXT-INTERNAL.H
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*/

%rename("_bt_context_create") bt_context_create(void);
%rename("_bt_context_add_trace") bt_context_add_trace(
		struct bt_context *ctx, const char *path, const char *format,
		void (*packet_seek)(struct bt_stream_pos *pos, size_t index, int whence),
		struct bt_mmap_stream_list *stream_list, FILE *metadata);
%rename("_bt_context_remove_trace") bt_context_remove_trace(
		struct bt_context *ctx, int trace_id);
%rename("_bt_context_get") bt_context_get(struct bt_context *ctx);
%rename("_bt_context_put") bt_context_put(struct bt_context *ctx);
%rename("_bt_ctf_event_get_context") bt_ctf_event_get_context(
		const struct bt_ctf_event *event);

struct bt_context *bt_context_create(void);
int bt_context_add_trace(struct bt_context *ctx, const char *path, const char *format,
		void (*packet_seek)(struct bt_stream_pos *pos, size_t index, int whence),
		struct bt_mmap_stream_list *stream_list, FILE *metadata);
void bt_context_remove_trace(struct bt_context *ctx, int trace_id);
void bt_context_get(struct bt_context *ctx);
void bt_context_put(struct bt_context *ctx);
struct bt_context *bt_ctf_event_get_context(const struct bt_ctf_event *event);

// class TraceCollection to prevent direct access to struct bt_context
%pythoncode%{
class TraceCollection:
	"""
	The TraceCollection is the object that contains all currently opened traces.
	"""

	def __init__(self):
		self._tc = _bt_context_create()

	def __del__(self):
		_bt_context_put(self._tc)

	def add_trace(self, path, format_str):
		"""
		Add a trace by path to the TraceCollection.

		Open a trace.

		path is the path to the trace, it is not recursive.
		If "path" is None, stream_list is used instead as a list
		of mmap streams to open for the trace.

		format is a string containing the format name in which the trace was
		produced.

		Return: the corresponding TraceHandle on success or None on error.
		"""
		ret = _bt_context_add_trace(self._tc, path, format_str, None, None, None)
		if ret < 0:
			return None

		th = TraceHandle.__new__(TraceHandle)
		th._id = ret
		th._trace_collection = self
		return th

	def add_traces_recursive(self, path, format_str):
		"""
		Open a trace recursively.

		Find each trace present in the subdirectory starting from the given
		path, and add them to the TraceCollection.

		Return a dict of TraceHandle instances (the full path is the key).
		Return None on error.
		"""

		import os

		trace_handles = {}

		noTrace = True
		error = False

		for fullpath, dirs, files in os.walk(path):
			if "metadata" in files:
				trace_handle = self.add_trace(fullpath, format_str)
				if trace_handle is None:
					error = True
					continue

				trace_handles[fullpath] = trace_handle
				noTrace = False

		if noTrace and error:
			return None
		return trace_handles

	def remove_trace(self, trace_handle):
		"""
		Remove a trace from the TraceCollection.
		Effectively closing the trace.
		"""
		try:
			_bt_context_remove_trace(self._tc, trace_handle._id)
		except AttributeError:
			raise TypeError("in remove_trace, "
				"argument 2 must be a TraceHandle instance")

	@property
	def events(self):
		"""
		Generator function to iterate over the events of open in the current
		TraceCollection.

		Due to limitations of the native Babeltrace API, only one event
		may be "alive" at a time (i.e. a user should never store a copy
		of the events returned by this function for ulterior use). Users
		shall make sure to copy the information they need from an event
		before accessing the next one.

		Furthermore, event objects become invalid when the generator goes
		out of scope as the underlying iterator will be reclaimed. Using an
		event after the the generator has gone out of scope may result in a
		crash or data corruption.
		"""
		begin_pos_ptr = _bt_python_create_iter_pos()
		end_pos_ptr = _bt_python_create_iter_pos()
		begin_pos_ptr.type = SEEK_BEGIN
		end_pos_ptr.type = SEEK_LAST

		for event in self._events(begin_pos_ptr, end_pos_ptr):
			yield event

		_bt_iter_free_pos(begin_pos_ptr)
		_bt_iter_free_pos(end_pos_ptr)

	def events_timestamps(self, timestamp_begin, timestamp_end):
		"""
		Generator function to iterate over the events of open in the current
		TraceCollection from timestamp_begin to timestamp_end.
		"""
		begin_pos_ptr = _bt_python_create_iter_pos()
		end_pos_ptr = _bt_python_create_iter_pos()
		begin_pos_ptr.type = end_pos_ptr.type = SEEK_TIME
		begin_pos_ptr.u.seek_time = timestamp_begin
		end_pos_ptr.u.seek_time = timestamp_end

		for event in self._events(begin_pos_ptr, end_pos_ptr):
			yield event

		_bt_iter_free_pos(begin_pos_ptr)
		_bt_iter_free_pos(end_pos_ptr)

	@property
	def timestamp_begin(self):
		pos_ptr = _bt_iter_pos()
		pos_ptr.type = SEEK_BEGIN
		return self._timestamp_at_pos(pos_ptr)

	@property
	def timestamp_end(self):
		pos_ptr = _bt_iter_pos()
		pos_ptr.type = SEEK_LAST
		return self._timestamp_at_pos(pos_ptr)

	def _timestamp_at_pos(self, pos_ptr):
		ctf_it_ptr = _bt_ctf_iter_create(self._tc, pos_ptr, pos_ptr)
		if ctf_it_ptr is None:
			raise NotImplementedError("Creation of multiple iterators is unsupported.")
		ev_ptr = _bt_ctf_iter_read_event(ctf_it_ptr)
		_bt_ctf_iter_destroy(ctf_it_ptr)
		if ev_ptr is None:
			return None;

	def _events(self, begin_pos_ptr, end_pos_ptr):
		ctf_it_ptr = _bt_ctf_iter_create(self._tc, begin_pos_ptr, end_pos_ptr)
		if ctf_it_ptr is None:
			raise NotImplementedError(
				"Creation of multiple iterators is unsupported.")

		while True:
			ev_ptr = _bt_ctf_iter_read_event(ctf_it_ptr)
			if ev_ptr is None:
				break

			ev = Event.__new__(Event)
			ev._e = ev_ptr
			try:
				yield ev
			except GeneratorExit:
				break

			ret = _bt_iter_next(_bt_ctf_get_iter(ctf_it_ptr))
			if ret != 0:
				break

		_bt_ctf_iter_destroy(ctf_it_ptr)

%}



/* =================================================================
		FORMAT.H, REGISTRY
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*/

%rename("lookup_format") bt_lookup_format(bt_intern_str qname);
%rename("_bt_print_format_list") bt_fprintf_format_list(FILE *fp);
%rename("register_format") bt_register_format(struct format *format);
%rename("unregister_format") bt_unregister_format(struct bt_format *format);

extern struct format *bt_lookup_format(bt_intern_str qname);
extern void bt_fprintf_format_list(FILE *fp);
extern int bt_register_format(struct bt_format *format);
extern void bt_unregister_format(struct bt_format *format);

%pythoncode %{

def print_format_list(babeltrace_file):
	"""
	Print a list of available formats to file.

	babeltrace_file must be a File instance opened in write mode.
	"""
	try:
		if babeltrace_file._file is not None:
			_bt_print_format_list(babeltrace_file._file)
	except AttributeError:
		raise TypeError("in print_format_list, "
			"argument 1 must be a File instance")

%}


/* =================================================================
		ITERATOR.H, ITERATOR-INTERNAL.H
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*/

%rename("_bt_iter_create") bt_iter_create(struct bt_context *ctx,
		const struct bt_iter_pos *begin_pos, const struct bt_iter_pos *end_pos);
%rename("_bt_iter_destroy") bt_iter_destroy(struct bt_iter *iter);
%rename("_bt_iter_next") bt_iter_next(struct bt_iter *iter);
%rename("_bt_iter_get_pos") bt_iter_get_pos(struct bt_iter *iter);
%rename("_bt_iter_free_pos") bt_iter_free_pos(struct bt_iter_pos *pos);
%rename("_bt_iter_set_pos") bt_iter_set_pos(struct bt_iter *iter,
		const struct bt_iter_pos *pos);
%rename("_bt_iter_create_time_pos") bt_iter_create_time_pos(struct bt_iter *iter,
		uint64_t timestamp);

struct bt_iter *bt_iter_create(struct bt_context *ctx,
		const struct bt_iter_pos *begin_pos, const struct bt_iter_pos *end_pos);
void bt_iter_destroy(struct bt_iter *iter);
int bt_iter_next(struct bt_iter *iter);
struct bt_iter_pos *bt_iter_get_pos(struct bt_iter *iter);
void bt_iter_free_pos(struct bt_iter_pos *pos);
int bt_iter_set_pos(struct bt_iter *iter, const struct bt_iter_pos *pos);
struct bt_iter_pos *bt_iter_create_time_pos(struct bt_iter *iter, uint64_t timestamp);

%rename("_bt_iter_pos") bt_iter_pos;
%rename("SEEK_TIME") BT_SEEK_TIME;
%rename("SEEK_RESTORE") BT_SEEK_RESTORE;
%rename("SEEK_CUR") BT_SEEK_CUR;
%rename("SEEK_BEGIN") BT_SEEK_BEGIN;
%rename("SEEK_LAST") BT_SEEK_LAST;

// This struct is taken from iterator.h
// All changes to the struct must also be made here
struct bt_iter_pos {
	enum {
		BT_SEEK_TIME,		/* uses u.seek_time */
		BT_SEEK_RESTORE,	/* uses u.restore */
		BT_SEEK_CUR,
		BT_SEEK_BEGIN,
		BT_SEEK_LAST
	} type;
	union {
		uint64_t seek_time;
		struct bt_saved_pos *restore;
	} u;
};

/* =================================================================
		TRACE-HANDLE.H, TRACE-HANDLE-INTERNAL.H
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*/

%rename("_bt_trace_handle_create") bt_trace_handle_create(struct bt_context *ctx);
%rename("_bt_trace_handle_destroy") bt_trace_handle_destroy(struct bt_trace_handle *bt);
struct bt_trace_handle *bt_trace_handle_create(struct bt_context *ctx);
void bt_trace_handle_destroy(struct bt_trace_handle *bt);

%rename("_bt_trace_handle_get_path") bt_trace_handle_get_path(struct bt_context *ctx,
		int handle_id);
%rename("_bt_trace_handle_get_timestamp_begin") bt_trace_handle_get_timestamp_begin(
		struct bt_context *ctx, int handle_id, enum bt_clock_type type);
%rename("_bt_trace_handle_get_timestamp_end") bt_trace_handle_get_timestamp_end(
		struct bt_context *ctx, int handle_id, enum bt_clock_type type);
const char *bt_trace_handle_get_path(struct bt_context *ctx, int handle_id);
uint64_t bt_trace_handle_get_timestamp_begin(struct bt_context *ctx, int handle_id,
		enum bt_clock_type type);
uint64_t bt_trace_handle_get_timestamp_end(struct bt_context *ctx, int handle_id,
		enum bt_clock_type type);

%rename("_bt_ctf_event_get_handle_id") bt_ctf_event_get_handle_id(
		const struct bt_ctf_event *event);
int bt_ctf_event_get_handle_id(const struct bt_ctf_event *event);


%pythoncode%{

# Based on enum bt_clock_type in clock-type.h
class ClockType:
	CLOCK_CYCLES = 0
	CLOCK_REAL = 1

class TraceHandle(object):
	"""
	The TraceHandle allows the user to manipulate a trace file directly.
	It is a unique identifier representing a trace file.
	Do not instantiate.
	"""

	def __init__(self):
		raise NotImplementedError("TraceHandle cannot be instantiated")

	def __repr__(self):
		return "Babeltrace TraceHandle: trace_id('{0}')".format(self._id)

	@property
	def id(self):
		"""Return the TraceHandle id."""
		return self._id

	@property
	def path(self):
		"""Return the path of a TraceHandle."""
		return _bt_trace_handle_get_path(self._trace_collection._tc, self._id)

	@property
	def timestamp_begin(self):
		"""Return the creation time of the buffers of a trace."""
		return _bt_trace_handle_get_timestamp_begin(
			self._trace_collection._tc, self._id, ClockType.CLOCK_REAL)

	@property
	def timestamp_end(self):
		"""Return the destruction timestamp of the buffers of a trace."""
		return _bt_trace_handle_get_timestamp_end(
			self._trace_collection._tc, self._id, ClockType.CLOCK_REAL)

	@property
	def events(self):
		"""
		Generator returning all events (EventDeclaration) in a trace.
		"""
		ret = _bt_python_event_decl_listcaller(self.id, self._trace_collection._tc)

		if not isinstance(ret, list):
			return

		ptr_list, count = ret
		for i in range(count):
			tmp = EventDeclaration.__new__(EventDeclaration)
			tmp._ed =  _bt_python_decl_one_from_list(ptr_list, i)
			yield tmp

%}



// =================================================================
//				CTF
// =================================================================

/* =================================================================
		ITERATOR.H, EVENTS.H
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*/

//Iterator
%rename("_bt_ctf_iter_create") bt_ctf_iter_create(struct bt_context *ctx,
		const struct bt_iter_pos *begin_pos,
		const struct bt_iter_pos *end_pos);
%rename("_bt_ctf_get_iter") bt_ctf_get_iter(struct bt_ctf_iter *iter);
%rename("_bt_ctf_iter_destroy") bt_ctf_iter_destroy(struct bt_ctf_iter *iter);
%rename("_bt_ctf_iter_read_event") bt_ctf_iter_read_event(struct bt_ctf_iter *iter);

struct bt_ctf_iter *bt_ctf_iter_create(struct bt_context *ctx,
		const struct bt_iter_pos *begin_pos,
		const struct bt_iter_pos *end_pos);
struct bt_iter *bt_ctf_get_iter(struct bt_ctf_iter *iter);
void bt_ctf_iter_destroy(struct bt_ctf_iter *iter);
struct bt_ctf_event *bt_ctf_iter_read_event(struct bt_ctf_iter *iter);


//Events
%rename("_bt_ctf_get_top_level_scope") bt_ctf_get_top_level_scope(const struct
		bt_ctf_event *event, enum bt_ctf_scope scope);
%rename("_bt_ctf_event_name") bt_ctf_event_name(const struct bt_ctf_event *ctf_event);
%rename("_bt_ctf_get_timestamp") bt_ctf_get_timestamp(
		const struct bt_ctf_event *ctf_event);
%rename("_bt_ctf_get_cycles") bt_ctf_get_cycles(
		const struct bt_ctf_event *ctf_event);

%rename("_bt_ctf_get_field") bt_ctf_get_field(const struct bt_ctf_event *ctf_event,
		const struct bt_definition *scope,	const char *field);
%rename("_bt_ctf_get_index") bt_ctf_get_index(const struct bt_ctf_event *ctf_event,
		const struct bt_definition *field,	unsigned int index);
%rename("_bt_ctf_field_name") bt_ctf_field_name(const struct bt_definition *field);
%rename("_bt_ctf_field_type") bt_ctf_field_type(const struct bt_declaration *field);
%rename("_bt_ctf_get_int_signedness") bt_ctf_get_int_signedness(
		const struct bt_declaration *field);
%rename("_bt_ctf_get_int_base") bt_ctf_get_int_base(const struct bt_declaration *field);
%rename("_bt_ctf_get_int_byte_order") bt_ctf_get_int_byte_order(
		const struct bt_declaration *field);
%rename("_bt_ctf_get_int_len") bt_ctf_get_int_len(const struct bt_declaration *field);
%rename("_bt_ctf_get_enum_int") bt_ctf_get_enum_int(const struct bt_definition *field);
%rename("_bt_ctf_get_enum_str") bt_ctf_get_enum_str(const struct bt_definition *field);
%rename("_bt_ctf_get_encoding") bt_ctf_get_encoding(const struct bt_declaration *field);
%rename("_bt_ctf_get_array_len") bt_ctf_get_array_len(const struct bt_declaration *field);
%rename("_bt_ctf_get_uint64") bt_ctf_get_uint64(const struct bt_definition *field);
%rename("_bt_ctf_get_int64") bt_ctf_get_int64(const struct bt_definition *field);
%rename("_bt_ctf_get_char_array") bt_ctf_get_char_array(const struct bt_definition *field);
%rename("_bt_ctf_get_string") bt_ctf_get_string(const struct bt_definition *field);
%rename("_bt_ctf_get_float") bt_ctf_get_float(const struct bt_definition *field);
%rename("_bt_ctf_get_variant") bt_ctf_get_variant(const struct bt_definition *field);
%rename("_bt_ctf_field_get_error") bt_ctf_field_get_error(void);
%rename("_bt_ctf_get_decl_event_name") bt_ctf_get_decl_event_name(const struct
		bt_ctf_event_decl *event);
%rename("_bt_ctf_get_decl_field_name") bt_ctf_get_decl_field_name(
		const struct bt_ctf_field_decl *field);
%rename("_bt_ctf_get_decl_from_def") bt_ctf_get_decl_from_def(
		const struct bt_definition *field);
%rename("_bt_ctf_get_decl_from_field_decl") bt_ctf_get_decl_from_field_decl(
		const struct bt_ctf_field_decl *field);
%rename("_bt_array_index") bt_array_index(struct definition_array *array, uint64_t i);
%rename("_bt_sequence_len")  bt_sequence_len(struct definition_sequence *sequence);
%rename("_bt_sequence_index") bt_sequence_index(struct definition_sequence *sequence, uint64_t i);
%rename("_bt_ctf_get_struct_field_count") bt_ctf_get_struct_field_count(const struct bt_definition *structure);
%rename("_bt_ctf_get_struct_field_index") bt_ctf_get_struct_field_index(const struct bt_definition *structure, uint64_t i);

const struct bt_definition *bt_ctf_get_top_level_scope(const struct bt_ctf_event *ctf_event,
		enum bt_ctf_scope scope);
const char *bt_ctf_event_name(const struct bt_ctf_event *ctf_event);
uint64_t bt_ctf_get_timestamp(const struct bt_ctf_event *ctf_event);
uint64_t bt_ctf_get_cycles(const struct bt_ctf_event *ctf_event);
const struct bt_definition *bt_ctf_get_field(const struct bt_ctf_event *ctf_event,
		const struct bt_definition *scope,
		const char *field);
const struct bt_definition *bt_ctf_get_index(const struct bt_ctf_event *ctf_event,
		const struct bt_definition *field,
		unsigned int index);
const char *bt_ctf_field_name(const struct bt_definition *field);
enum ctf_type_id bt_ctf_field_type(const struct bt_declaration *field);
int bt_ctf_get_int_signedness(const struct bt_declaration *field);
int bt_ctf_get_int_base(const struct bt_declaration *field);
int bt_ctf_get_int_byte_order(const struct bt_declaration *field);
ssize_t bt_ctf_get_int_len(const struct bt_declaration *field);
const struct bt_definition *bt_ctf_get_enum_int(const struct bt_definition *field);
const char *bt_ctf_get_enum_str(const struct bt_definition *field);
enum ctf_string_encoding bt_ctf_get_encoding(const struct bt_declaration *field);
int bt_ctf_get_array_len(const struct bt_declaration *field);
struct bt_definition *bt_array_index(struct definition_array *array, uint64_t i);
uint64_t bt_ctf_get_uint64(const struct bt_definition *field);
int64_t bt_ctf_get_int64(const struct bt_definition *field);
char *bt_ctf_get_char_array(const struct bt_definition *field);
char *bt_ctf_get_string(const struct bt_definition *field);
double bt_ctf_get_float(const struct bt_definition *field);
const struct bt_definition *bt_ctf_get_variant(const struct bt_definition *field);
int bt_ctf_field_get_error(void);
const char *bt_ctf_get_decl_event_name(const struct bt_ctf_event_decl *event);
const char *bt_ctf_get_decl_field_name(const struct bt_ctf_field_decl *field);
const struct bt_declaration *bt_ctf_get_decl_from_def(const struct bt_definition *field);
const struct bt_declaration *bt_ctf_get_decl_from_field_decl(const struct bt_ctf_field_decl *field);
uint64_t bt_sequence_len(struct definition_sequence *sequence);
struct bt_definition *bt_sequence_index(struct definition_sequence *sequence, uint64_t i);
uint64_t bt_ctf_get_struct_field_count(const struct bt_definition *structure);
const struct bt_definition *bt_ctf_get_struct_field_index(const struct bt_definition *structure, uint64_t i);

%pythoncode%{

class CTFStringEncoding:
	NONE = 0
	UTF8 = 1
	ASCII = 2
	UNKNOWN = 3

# Based on the enum in ctf-writer/writer.h
class ByteOrder:
	BYTE_ORDER_NATIVE = 0
	BYTE_ORDER_LITTLE_ENDIAN = 1
	BYTE_ORDER_BIG_ENDIAN = 2
	BYTE_ORDER_NETWORK = 3
	BYTE_ORDER_UNKNOWN = 4 # Python-specific entry

#enum equivalent, accessible constants
#These are taken directly from ctf/events.h
#All changes to enums must also be made here
class CTFTypeId:
	UNKNOWN = 0
	INTEGER = 1
	FLOAT = 2
	ENUM = 3
	STRING = 4
	STRUCT = 5
	UNTAGGED_VARIANT = 6
	VARIANT = 7
	ARRAY = 8
	SEQUENCE = 9
	NR_CTF_TYPES = 10

	def type_name(id):
		name = "UNKNOWN_TYPE"
		constants = [attr for attr in dir(CTFTypeId) if not callable(getattr(CTFTypeId, attr)) and not attr.startswith("__")]
		for attr in constants:
			if getattr(CTFTypeId, attr) == id:
				name = attr
				break
		return name

class CTFScope:
	TRACE_PACKET_HEADER = 0
	STREAM_PACKET_CONTEXT = 1
	STREAM_EVENT_HEADER = 2
	STREAM_EVENT_CONTEXT = 3
	EVENT_CONTEXT = 4
	EVENT_FIELDS = 5

	def scope_name(scope):
		name = "UNKNOWN_SCOPE"
		constants = [attr for attr in dir(CTFScope) if not callable(getattr(CTFScope, attr)) and not attr.startswith("__")]
		for attr in constants:
			if getattr(CTFScope, attr) == scope:
				name = attr
				break
		return name

# Priority of the scopes when searching for event fields
_scopes = [CTFScope.EVENT_FIELDS, CTFScope.EVENT_CONTEXT, CTFScope.STREAM_EVENT_CONTEXT,
	CTFScope.STREAM_EVENT_HEADER, CTFScope.STREAM_PACKET_CONTEXT, CTFScope.TRACE_PACKET_HEADER]

import collections
class Event(collections.Mapping):
	"""
	This class represents an event from the trace.
	It is obtained using the TraceCollection generator functions.
	Do not instantiate.
	"""
	def __init__(self):
		raise NotImplementedError("Event cannot be instantiated")

	@property
	def name(self):
		"""Return the name of the event or None on error."""
		return _bt_ctf_event_name(self._e)

	@property
	def cycles(self):
		"""
		Return the timestamp of the event as written in
		the packet (in cycles) or -1ULL on error.
		"""
		return _bt_ctf_get_cycles(self._e)

	@property
	def timestamp(self):
		"""
		Return the timestamp of the event offset with the
		system clock source or -1ULL on error.
		"""
		return _bt_ctf_get_timestamp(self._e)

	def field_with_scope(self, field_name, scope):
		"""
		Get field_name's value in scope.
		None is returned if no field matches field_name.
		"""
		if not scope in _scopes:
			raise ValueError("Invalid scope provided")
		field = self._field_with_scope(field_name, scope)
		if field is not None:
			return field.value
		return None

	def field_list_with_scope(self, scope):
		"""Return a list of field names in scope."""
		if not scope in _scopes:
			raise ValueError("Invalid scope provided")
		field_names = []
		for field in self._field_list_with_scope(scope):
			field_names.append(field.name)
		return field_names

	@property
	def handle(self):
		"""
		Get the TraceHandle associated with this event
		Return None on error
		"""
		ret = _bt_ctf_event_get_handle_id(self._e)
		if ret < 0:
			return None

		th = TraceHandle.__new__(TraceHandle)
		th._id = ret
		th._trace_collection = self.get_trace_collection()
		return th

	@property
	def trace_collection(self):
		"""
		Get the TraceCollection associated with this event.
		Return None on error.
		"""
		trace_collection = TraceCollection()
		trace_collection._tc = _bt_ctf_event_get_context(self._e);
		if trace_collection._tc is None:
			return None
		else:
			return trace_collection

	def __getitem__(self, field_name):
		"""
		Get field_name's value. If the field_name exists in multiple
		scopes, the first field found is returned. The scopes are searched
		in the following order:
		1) EVENT_FIELDS
		2) EVENT_CONTEXT
		3) STREAM_EVENT_CONTEXT
		4) STREAM_EVENT_HEADER
		5) STREAM_PACKET_CONTEXT
		6) TRACE_PACKET_HEADER
		None is returned if no field matches field_name.

		Use field_with_scope() to explicitly access fields in a given
		scope.
		"""
		field = self._field(field_name)
		if field is not None:
			return field.value
		raise KeyError(field_name)

	def __iter__(self):
		for key in self.keys():
			yield key

	def __len__(self):
		count = 0
		for scope in _scopes:
			scope_ptr = _bt_ctf_get_top_level_scope(self._e, scope)
			ret = _bt_python_field_listcaller(self._e, scope_ptr)
			if isinstance(ret, list):
				count += ret[1]
		return count

	def __contains__(self, field_name):
		return self._field(field_name) is not None

	def keys(self):
		"""Return a list of field names."""
		field_names = set()
		for scope in _scopes:
			for name in self.field_list_with_scope(scope):
				field_names.add(name)
		return list(field_names)

	def get(self, field_name, default = None):
		field = self._field(field_name)
		if field is None:
			return default
		return field.value

	def items(self):
		for field in self.keys():
			yield (field, self[field])

	def _field_with_scope(self, field_name, scope):
		scope_ptr = _bt_ctf_get_top_level_scope(self._e, scope)
		if scope_ptr is None:
			return None

		definition_ptr = _bt_ctf_get_field(self._e, scope_ptr, field_name)
		if definition_ptr is None:
			return None

		field = _Definition(definition_ptr, scope)
		return field

	def _field(self, field_name):
		field = None
		for scope in _scopes:
			field = self._field_with_scope(field_name, scope)
			if field is not None:
				break
		return field

	def _field_list_with_scope(self, scope):
		fields = []
		scope_ptr = _bt_ctf_get_top_level_scope(self._e, scope)
		
		# Returns a list [list_ptr, count]. If list_ptr is NULL, SWIG will only
		# provide the "count" return value
		count = 0
		list_ptr = None
		ret = _bt_python_field_listcaller(self._e, scope_ptr)
		if isinstance(ret, list):
			list_ptr, count = ret

		for i in range(count):
			definition_ptr = _bt_python_field_one_from_list(list_ptr, i)
			if definition_ptr is not None:
				definition = _Definition(definition_ptr, scope)
				fields.append(definition)
		return fields

class FieldError(Exception):
	def __init__(self, value):
		self.value = value

	def __str__(self):
		return repr(self.value)

class EventDeclaration(object):
	"""Event declaration class.  Do not instantiate."""

	def __init__(self):
		raise NotImplementedError("EventDeclaration cannot be instantiated")

	@property
	def name(self):
		"""Return the name of the event or None on error"""
		return _bt_ctf_get_decl_event_name(self._ed)

	@property
	def fields(self):
		"""
		Generator returning all FieldDeclarations of an event, going through
		each scope in the following order:
		1) EVENT_FIELDS
		2) EVENT_CONTEXT
		3) STREAM_EVENT_CONTEXT
		4) STREAM_EVENT_HEADER
		5) STREAM_PACKET_CONTEXT
		6) TRACE_PACKET_HEADER
		"""
		for scope in _scopes:
			for declaration in self.fields_scope(scope):
				yield declaration

	def fields_scope(self, scope):
		"""
		Generator returning FieldDeclarations of the current event in scope.
		"""
		ret = _by_python_field_decl_listcaller(self._ed, scope)

		if not isinstance(ret, list):
			return

		list_ptr, count = ret
		for i in range(count):
			field_declaration_ptr = _bt_python_field_decl_one_from_list(list_ptr, i)
			if field_declaration_ptr is not None:
				declaration_ptr = _bt_ctf_get_decl_from_field_decl(field_declaration_ptr)
				field_declaration = _create_field_declaration(declaration_ptr, _bt_ctf_get_decl_field_name(field_declaration_ptr), scope)
				yield field_declaration

class FieldDeclaration(object):
	"""Field declaration class. Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("FieldDeclaration cannot be instantiated")

	def __repr__(self):
		return "({0}) {1} {2}".format(CTFScope.scope_name(self.scope), CTFTypeId.type_name(self.type), self.name)

	@property
	def name(self):
		"""Return the name of a FieldDeclaration or None on error."""
		return self._name

	@property
	def type(self):
		"""
		Return the FieldDeclaration's type. One of the entries in class
		CTFTypeId.
		"""
		return _bt_ctf_field_type(self._fd)

	@property
	def scope(self):
		"""
		Return the FieldDeclaration's scope.
		"""
		return self._s

class IntegerFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("IntegerFieldDeclaration cannot be instantiated")

	@property
	def signedness(self):
		"""
		Return the signedness of an integer:
		0 if unsigned; 1 if signed; -1 on error.
		"""
		return _bt_ctf_get_int_signedness(self._fd)

	@property
	def base(self):
		"""Return the base of an int or a negative value on error."""
		return _bt_ctf_get_int_base(self._fd)

	@property
	def byte_order(self):
		"""
		Return the byte order. One of class ByteOrder's entries.
		"""
		ret = _bt_ctf_get_int_byte_order(self._fd)
		if ret == 1234:
			return ByteOrder.BYTE_ORDER_LITTLE_ENDIAN
		elif ret == 4321:
			return ByteOrder.BYTE_ORDER_BIG_ENDIAN
		else:
			return ByteOrder.BYTE_ORDER_UNKNOWN

	@property
	def length(self):
		"""
		Return the size, in bits, of an int or a negative
		value on error.
		"""
		return _bt_ctf_get_int_len(self._fd)

	@property
	def encoding(self):
		"""
		Return the encoding. One of class CTFStringEncoding's entries.
		Return a negative value on error.
		"""
		return _bt_ctf_get_encoding(self._fd)

class EnumerationFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("EnumerationFieldDeclaration cannot be instantiated")

class ArrayFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("ArrayFieldDeclaration cannot be instantiated")

	@property
	def length(self):
		"""
		Return the length of an array or a negative
		value on error.
		"""
		return _bt_ctf_get_array_len(self._fd)

	@property
	def element_declaration(self):
		"""
		Return element declaration.
		"""
		field_decl_ptr = _bt_python_get_array_element_declaration(self._fd)
		return _create_field_declaration(field_decl_ptr, "", self.scope)

class SequenceFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("SequenceFieldDeclaration cannot be instantiated")

	@property
	def element_declaration(self):
		"""
		Return element declaration.
		"""
		field_decl_ptr = _bt_python_get_sequence_element_declaration(self._fd)
		return _create_field_declaration(field_decl_ptr, "", self.scope)

class FloatFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("FloatFieldDeclaration cannot be instantiated")

class StructureFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("StructureFieldDeclaration cannot be instantiated")

class StringFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("StringFieldDeclaration cannot be instantiated")

class VariantFieldDeclaration(FieldDeclaration):
	"""Do not instantiate."""
	def __init__(self):
		raise NotImplementedError("VariantFieldDeclaration cannot be instantiated")

def field_error():
	"""
	Return the last error code encountered while
	accessing a field and reset the error flag.
	Return 0 if no error, a negative value otherwise.
	"""
	return _bt_ctf_field_get_error()

def _create_field_declaration(declaration_ptr, name, scope):
	"""
	Private field declaration factory.
	"""
	if declaration_ptr is None:
		raise ValueError("declaration_ptr must be valid")
	if not scope in _scopes:
		raise ValueError("Invalid scope provided")

	type = _bt_ctf_field_type(declaration_ptr)
	declaration = None
	if type == CTFTypeId.INTEGER:
		declaration = IntegerFieldDeclaration.__new__(IntegerFieldDeclaration)
	elif type == CTFTypeId.ENUM:
		declaration = EnumerationFieldDeclaration.__new__(EnumerationFieldDeclaration)
	elif type == CTFTypeId.ARRAY:
		declaration = ArrayFieldDeclaration.__new__(ArrayFieldDeclaration)
	elif type == CTFTypeId.SEQUENCE:
		declaration = SequenceFieldDeclaration.__new__(SequenceFieldDeclaration)
	elif type == CTFTypeId.FLOAT:
		declaration = FloatFieldDeclaration.__new__(FloatFieldDeclaration)
	elif type == CTFTypeId.STRUCT:
		declaration = StructureFieldDeclaration.__new__(StructureFieldDeclaration)
	elif type == CTFTypeId.STRING:
		declaration = StringFieldDeclaration.__new__(StringFieldDeclaration)
	elif type == CTFTypeId.VARIANT:
		declaration = VariantFieldDeclaration.__new__(VariantFieldDeclaration)
	else:
		return declaration

	declaration._fd = declaration_ptr
	declaration._s = scope
	declaration._name = name
	return declaration

class _Definition(object):
	def __init__(self, definition_ptr, scope):
		self._d = definition_ptr
		self._s = scope
		if not scope in _scopes:
			ValueError("Invalid scope provided")

	@property
	def name(self):
		"""Return the name of a field or None on error."""
		return _bt_ctf_field_name(self._d)

	@property
	def type(self):
		"""Return the type of a field or -1 if unknown."""
		return _bt_ctf_field_type(_bt_ctf_get_decl_from_def(self._d))

	@property
	def declaration(self):
		"""Return the associated Definition object."""
		return _create_field_declaration(_bt_ctf_get_decl_from_def(self._d), self.name, self.scope)

	def _get_enum_str(self):
		"""
		Return the string matching the current enumeration.
		Return None on error.
		"""
		return _bt_ctf_get_enum_str(self._d)

	def _get_array_element_at(self, index):
		"""
		Return the array's element at position index.
		Return None on error
		"""
		array_ptr = _bt_python_get_array_from_def(self._d)
		if array_ptr is None:
			return None

		definition_ptr = _bt_array_index(array_ptr, index)
		if definition_ptr is None:
			return None
		return _Definition(definition_ptr, self.scope)

	def _get_sequence_len(self):
		"""
		Return the len of a sequence or a negative
		value on error.
		"""
		seq = _bt_python_get_sequence_from_def(self._d)
		return _bt_sequence_len(seq)

	def _get_sequence_element_at(self, index):
		"""
		Return the sequence's element at position index,
		otherwise return None
		"""
		seq = _bt_python_get_sequence_from_def(self._d)
		if seq is not None:
			definition_ptr = _bt_sequence_index(seq, index)
			if definition_ptr is not None:
				return _Definition(definition_ptr, self.scope)
		return None

	def _get_uint64(self):
		"""
		Return the value associated with the field.
		If the field does not exist or is not of the type requested,
		the value returned is undefined. To check if an error occured,
		use the	field_error() function after accessing a field.
		"""
		return _bt_ctf_get_uint64(self._d)

	def _get_int64(self):
		"""
		Return the value associated with the field.
		If the field does not exist or is not of the type requested,
		the value returned is undefined. To check if an error occured,
		use the field_error() function after accessing a field.
		"""
		return _bt_ctf_get_int64(self._d)

	def _get_char_array(self):
		"""
		Return the value associated with the field.
		If the field does not exist or is not of the type requested,
		the value returned is undefined. To check if an error occurred,
		use the field_error() function after accessing a field.
		"""
		return _bt_ctf_get_char_array(self._d)

	def _get_str(self):
		"""
		Return the value associated with the field.
		If the field does not exist or is not of the type requested,
		the value returned is undefined. To check if an error occurred,
		use the field_error() function after accessing a field.
		"""
		return _bt_ctf_get_string(self._d)

	def _get_float(self):
		"""
		Return the value associated with the field.
		If the field does not exist or is not of the type requested,
		the value returned is undefined. To check if an error occurred,
		use the field_error() function after accessing a field.
		"""
		return _bt_ctf_get_float(self._d)

	def _get_variant(self):
		"""
		Return the variant's selected field.
		If the field does not exist or is not of the type requested,
		the value returned is undefined. To check if an error occurred,
		use the field_error() function after accessing a field.
		"""
		return _bt_ctf_get_variant(self._d)

	def _get_struct_field_count(self):
		"""
		Return the number of fields contained in the structure.
		If the field does not exist or is not of the type requested,
		the value returned is undefined.
		"""
		return _bt_ctf_get_struct_field_count(self._d)

	def _get_struct_field_at(self, i):
		"""
		Return the structure's field at position i.
		If the field does not exist or is not of the type requested,
		the value returned is undefined. To check if an error occurred,
		use the field_error() function after accessing a field.
		"""
		return _bt_ctf_get_struct_field_index(self._d, i)

	@property
	def value(self):
		"""
		Return the value associated with the field according to its type.
		Return None on error.
		"""
		id = self.type
		value = None

		if id == CTFTypeId.STRING:
			value = self._get_str()
		elif id == CTFTypeId.ARRAY:
			element_decl = self.declaration.element_declaration
			if ((element_decl.type == CTFTypeId.INTEGER
				and element_decl.length == 8)
				and (element_decl.encoding == CTFStringEncoding.ASCII or element_decl.encoding == CTFStringEncoding.UTF8)):
				value = _bt_python_get_array_string(self._d)
			else:
				value = []
				for i in range(self.declaration.length):
					element = self._get_array_element_at(i)
					value.append(element.value)
		elif id == CTFTypeId.INTEGER:
			if self.declaration.signedness == 0:
				value = self._get_uint64()
			else:
				value = self._get_int64()
		elif id == CTFTypeId.ENUM:
			value = self._get_enum_str()
		elif id == CTFTypeId.SEQUENCE:
			element_decl = self.declaration.element_declaration
			if ((element_decl.type == CTFTypeId.INTEGER
				and element_decl.length == 8)
				and (element_decl.encoding == CTFStringEncoding.ASCII or element_decl.encoding == CTFStringEncoding.UTF8)):
				value = _bt_python_get_sequence_string(self._d)
			else:
				seq_len = self._get_sequence_len()
				value = []
				for i in range(seq_len):
					evDef = self._get_sequence_element_at(i)
					value.append(evDef.value)
		elif id == CTFTypeId.FLOAT:
			value = self._get_float()
		elif id == CTFTypeId.VARIANT:
			variant = _Definition.__new__(_Definition)
			variant._d = self._get_variant();
			value = variant.value
		elif id == CTFTypeId.STRUCT:
			value = {}
			for i in range(self._get_struct_field_count()):
				member = _Definition(self._get_struct_field_at(i), self.scope)
				value[member.name] = member.value

		if field_error():
			raise FieldError("Error occurred while accessing field {} of type {}".format(self.name, CTFTypeId.type_name(id)))
		return value

	@property
	def scope(self):
		"""Return the scope of a field or None on error."""
		return self._s

%}


// =================================================================
//				CTF Writer
// =================================================================

/* =================================================================
			CLOCK.H
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*/
%rename("_bt_ctf_clock_create") bt_ctf_clock_create(const char *name);
%rename("_bt_ctf_clock_set_description") bt_ctf_clock_set_description(struct bt_ctf_clock *clock, const char *desc);
%rename("_bt_ctf_clock_set_frequency") bt_ctf_clock_set_frequency(struct bt_ctf_clock *clock, uint64_t freq);
%rename("_bt_ctf_clock_set_precision") bt_ctf_clock_set_precision(struct bt_ctf_clock *clock, uint64_t precision);
%rename("_bt_ctf_clock_set_offset_s") bt_ctf_clock_set_offset_s(struct bt_ctf_clock *clock, uint64_t offset_s);
%rename("_bt_ctf_clock_set_offset") bt_ctf_clock_set_offset(struct bt_ctf_clock *clock, uint64_t offset);
%rename("_bt_ctf_clock_set_is_absolute") bt_ctf_clock_set_is_absolute(struct bt_ctf_clock *clock, int is_absolute);
%rename("_bt_ctf_clock_set_time") bt_ctf_clock_set_time(struct bt_ctf_clock *clock, uint64_t time);
%rename("_bt_ctf_clock_get") bt_ctf_clock_get(struct bt_ctf_clock *clock);
%rename("_bt_ctf_clock_put") bt_ctf_clock_put(struct bt_ctf_clock *clock);

struct bt_ctf_clock *bt_ctf_clock_create(const char *name);
int bt_ctf_clock_set_description(struct bt_ctf_clock *clock, const char *desc);
int bt_ctf_clock_set_frequency(struct bt_ctf_clock *clock, uint64_t freq);
int bt_ctf_clock_set_precision(struct bt_ctf_clock *clock, uint64_t precision);
int bt_ctf_clock_set_offset_s(struct bt_ctf_clock *clock, uint64_t offset_s);
int bt_ctf_clock_set_offset(struct bt_ctf_clock *clock, uint64_t offset);
int bt_ctf_clock_set_is_absolute(struct bt_ctf_clock *clock, int is_absolute);
int bt_ctf_clock_set_time(struct bt_ctf_clock *clock, uint64_t time);
void bt_ctf_clock_get(struct bt_ctf_clock *clock);
void bt_ctf_clock_put(struct bt_ctf_clock *clock);

/* =================================================================
			EVENT-TYPES.H
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*/
%rename("_bt_ctf_field_type_integer_create") bt_ctf_field_type_integer_create(unsigned int size);
%rename("_bt_ctf_field_type_integer_set_signed") bt_ctf_field_type_integer_set_signed(struct bt_ctf_field_type *integer, int is_signed);
%rename("_bt_ctf_field_type_integer_set_base") bt_ctf_field_type_integer_set_base(struct bt_ctf_field_type *integer, enum bt_ctf_integer_base base);
%rename("_bt_ctf_field_type_integer_set_encoding") bt_ctf_field_type_integer_set_encoding(struct bt_ctf_field_type *integer, enum ctf_string_encoding encoding);
%rename("_bt_ctf_field_type_enumeration_create") bt_ctf_field_type_enumeration_create(struct bt_ctf_field_type *integer_container_type);
%rename("_bt_ctf_field_type_enumeration_add_mapping") bt_ctf_field_type_enumeration_add_mapping(struct bt_ctf_field_type *enumeration, const char *string, int64_t range_start, int64_t range_end);
%rename("_bt_ctf_field_type_floating_point_create") bt_ctf_field_type_floating_point_create(void);
%rename("_bt_ctf_field_type_floating_point_set_exponent_digits") bt_ctf_field_type_floating_point_set_exponent_digits(struct bt_ctf_field_type *floating_point, unsigned int exponent_digits);
%rename("_bt_ctf_field_type_floating_point_set_mantissa_digits") bt_ctf_field_type_floating_point_set_mantissa_digits(struct bt_ctf_field_type *floating_point, unsigned int mantissa_digits);
%rename("_bt_ctf_field_type_structure_create") bt_ctf_field_type_structure_create(void);
%rename("_bt_ctf_field_type_structure_add_field") bt_ctf_field_type_structure_add_field(struct bt_ctf_field_type *structure, struct bt_ctf_field_type *field_type, const char *field_name);
%rename("_bt_ctf_field_type_variant_create") bt_ctf_field_type_variant_create(struct bt_ctf_field_type *enum_tag, const char *tag_name);
%rename("_bt_ctf_field_type_variant_add_field") bt_ctf_field_type_variant_add_field(struct bt_ctf_field_type *variant, struct bt_ctf_field_type *field_type, const char *field_name);
%rename("_bt_ctf_field_type_array_create") bt_ctf_field_type_array_create(struct bt_ctf_field_type *element_type, unsigned int length);
%rename("_bt_ctf_field_type_sequence_create") bt_ctf_field_type_sequence_create(struct bt_ctf_field_type *element_type, const char *length_field_name);
%rename("_bt_ctf_field_type_string_create") bt_ctf_field_type_string_create(void);
%rename("_bt_ctf_field_type_string_set_encoding") bt_ctf_field_type_string_set_encoding(struct bt_ctf_field_type *string, enum ctf_string_encoding encoding);
%rename("_bt_ctf_field_type_set_alignment") bt_ctf_field_type_set_alignment(struct bt_ctf_field_type *type, unsigned int alignment);
%rename("_bt_ctf_field_type_set_byte_order") bt_ctf_field_type_set_byte_order(struct bt_ctf_field_type *type, enum bt_ctf_byte_order byte_order);
%rename("_bt_ctf_field_type_get") bt_ctf_field_type_get(struct bt_ctf_field_type *type);
%rename("_bt_ctf_field_type_put") bt_ctf_field_type_put(struct bt_ctf_field_type *type);

struct bt_ctf_field_type *bt_ctf_field_type_integer_create(unsigned int size);
int bt_ctf_field_type_integer_set_signed(struct bt_ctf_field_type *integer, int is_signed);
int bt_ctf_field_type_integer_set_base(struct bt_ctf_field_type *integer, enum bt_ctf_integer_base base);
int bt_ctf_field_type_integer_set_encoding(struct bt_ctf_field_type *integer, enum ctf_string_encoding encoding);
struct bt_ctf_field_type *bt_ctf_field_type_enumeration_create(struct bt_ctf_field_type *integer_container_type);
int bt_ctf_field_type_enumeration_add_mapping(struct bt_ctf_field_type *enumeration, const char *string, int64_t range_start, int64_t range_end);
struct bt_ctf_field_type *bt_ctf_field_type_floating_point_create(void);
int bt_ctf_field_type_floating_point_set_exponent_digits(struct bt_ctf_field_type *floating_point, unsigned int exponent_digits);
int bt_ctf_field_type_floating_point_set_mantissa_digits(struct bt_ctf_field_type *floating_point, unsigned int mantissa_digits);
struct bt_ctf_field_type *bt_ctf_field_type_structure_create(void);
int bt_ctf_field_type_structure_add_field(struct bt_ctf_field_type *structure, struct bt_ctf_field_type *field_type, const char *field_name);
struct bt_ctf_field_type *bt_ctf_field_type_variant_create(struct bt_ctf_field_type *enum_tag, const char *tag_name);
int bt_ctf_field_type_variant_add_field(struct bt_ctf_field_type *variant, struct bt_ctf_field_type *field_type, const char *field_name);
struct bt_ctf_field_type *bt_ctf_field_type_array_create(struct bt_ctf_field_type *element_type, unsigned int length);
struct bt_ctf_field_type *bt_ctf_field_type_sequence_create(struct bt_ctf_field_type *element_type, const char *length_field_name);
struct bt_ctf_field_type *bt_ctf_field_type_string_create(void);
int bt_ctf_field_type_string_set_encoding(struct bt_ctf_field_type *string, enum ctf_string_encoding encoding);
int bt_ctf_field_type_set_alignment(struct bt_ctf_field_type *type, unsigned int alignment);
int bt_ctf_field_type_set_byte_order(struct bt_ctf_field_type *type, enum bt_ctf_byte_order byte_order);
void bt_ctf_field_type_get(struct bt_ctf_field_type *type);
void bt_ctf_field_type_put(struct bt_ctf_field_type *type);

/* =================================================================
			EVENT-FIELDS.H
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*/
%rename("_bt_ctf_field_create") bt_ctf_field_create(struct bt_ctf_field_type *type);
%rename("_bt_ctf_field_structure_get_field") bt_ctf_field_structure_get_field(struct bt_ctf_field *structure, const char *name);
%rename("_bt_ctf_field_array_get_field") bt_ctf_field_array_get_field(struct bt_ctf_field *array, uint64_t index);
%rename("_bt_ctf_field_sequence_set_length") bt_ctf_field_sequence_set_length(struct bt_ctf_field *sequence, struct bt_ctf_field *length_field);
%rename("_bt_ctf_field_sequence_get_field") bt_ctf_field_sequence_get_field(struct bt_ctf_field *sequence, uint64_t index);
%rename("_bt_ctf_field_variant_get_field") bt_ctf_field_variant_get_field(struct bt_ctf_field *variant, struct bt_ctf_field *tag);
%rename("_bt_ctf_field_enumeration_get_container") bt_ctf_field_enumeration_get_container(struct bt_ctf_field *enumeration);
%rename("_bt_ctf_field_signed_integer_set_value") bt_ctf_field_signed_integer_set_value(struct bt_ctf_field *integer, int64_t value);
%rename("_bt_ctf_field_unsigned_integer_set_value") bt_ctf_field_unsigned_integer_set_value(struct bt_ctf_field *integer, uint64_t value);
%rename("_bt_ctf_field_floating_point_set_value") bt_ctf_field_floating_point_set_value(struct bt_ctf_field *floating_point, double value);
%rename("_bt_ctf_field_string_set_value") bt_ctf_field_string_set_value(struct bt_ctf_field *string, const char *value);
%rename("_bt_ctf_field_get") bt_ctf_field_get(struct bt_ctf_field *field);
%rename("_bt_ctf_field_put") bt_ctf_field_put(struct bt_ctf_field *field);

struct bt_ctf_field *bt_ctf_field_create(struct bt_ctf_field_type *type);
struct bt_ctf_field *bt_ctf_field_structure_get_field(struct bt_ctf_field *structure, const char *name);
struct bt_ctf_field *bt_ctf_field_array_get_field(struct bt_ctf_field *array, uint64_t index);
int bt_ctf_field_sequence_set_length(struct bt_ctf_field *sequence, struct bt_ctf_field *length_field);
struct bt_ctf_field *bt_ctf_field_sequence_get_field(struct bt_ctf_field *sequence, uint64_t index);
struct bt_ctf_field *bt_ctf_field_variant_get_field(struct bt_ctf_field *variant, struct bt_ctf_field *tag);
struct bt_ctf_field *bt_ctf_field_enumeration_get_container(struct bt_ctf_field *enumeration);
int bt_ctf_field_signed_integer_set_value(struct bt_ctf_field *integer, int64_t value);
int bt_ctf_field_unsigned_integer_set_value(struct bt_ctf_field *integer, uint64_t value);
int bt_ctf_field_floating_point_set_value(struct bt_ctf_field *floating_point, double value);
int bt_ctf_field_string_set_value(struct bt_ctf_field *string, const char *value);
void bt_ctf_field_get(struct bt_ctf_field *field);
void bt_ctf_field_put(struct bt_ctf_field *field);

/* =================================================================
			EVENT.H
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*/
%rename("_bt_ctf_event_class_create") bt_ctf_event_class_create(const char *name);
%rename("_bt_ctf_event_class_add_field") bt_ctf_event_class_add_field(struct bt_ctf_event_class *event_class, struct bt_ctf_field_type *type, const char *name);
%rename("_bt_ctf_event_class_get") bt_ctf_event_class_get(struct bt_ctf_event_class *event_class);
%rename("_bt_ctf_event_class_put") bt_ctf_event_class_put(struct bt_ctf_event_class *event_class);
%rename("_bt_ctf_event_create") bt_ctf_event_create(struct bt_ctf_event_class *event_class);
%rename("_bt_ctf_event_set_payload") bt_ctf_event_set_payload(struct bt_ctf_event *event, const char *name, struct bt_ctf_field *value);
%rename("_bt_ctf_event_get_payload") bt_ctf_event_get_payload(struct bt_ctf_event *event, const char *name);
%rename("_bt_ctf_event_get") bt_ctf_event_get(struct bt_ctf_event *event);
%rename("_bt_ctf_event_put") bt_ctf_event_put(struct bt_ctf_event *event);

struct bt_ctf_event_class *bt_ctf_event_class_create(const char *name);
int bt_ctf_event_class_add_field(struct bt_ctf_event_class *event_class, struct bt_ctf_field_type *type, const char *name);
void bt_ctf_event_class_get(struct bt_ctf_event_class *event_class);
void bt_ctf_event_class_put(struct bt_ctf_event_class *event_class);
struct bt_ctf_event *bt_ctf_event_create(struct bt_ctf_event_class *event_class);
int bt_ctf_event_set_payload(struct bt_ctf_event *event, const char *name, struct bt_ctf_field *value);
struct bt_ctf_field *bt_ctf_event_get_payload(struct bt_ctf_event *event, const char *name);
void bt_ctf_event_get(struct bt_ctf_event *event);
void bt_ctf_event_put(struct bt_ctf_event *event);

/* =================================================================
			STREAM.H
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*/
%rename("_bt_ctf_stream_class_create") bt_ctf_stream_class_create(const char *name);
%rename("_bt_ctf_stream_class_set_clock") bt_ctf_stream_class_set_clock(struct bt_ctf_stream_class *stream_class, struct bt_ctf_clock *clock);
%rename("_bt_ctf_stream_class_add_event_class") bt_ctf_stream_class_add_event_class(struct bt_ctf_stream_class *stream_class, struct bt_ctf_event_class *event_class);
%rename("_bt_ctf_stream_class_get") bt_ctf_stream_class_get(struct bt_ctf_stream_class *stream_class);
%rename("_bt_ctf_stream_class_put") bt_ctf_stream_class_put(struct bt_ctf_stream_class *stream_class);
%rename("_bt_ctf_stream_append_discarded_events") bt_ctf_stream_append_discarded_events(struct bt_ctf_stream *stream, uint64_t event_count);
%rename("_bt_ctf_stream_append_event") bt_ctf_stream_append_event(struct bt_ctf_stream *stream, struct bt_ctf_event *event);
%rename("_bt_ctf_stream_flush") bt_ctf_stream_flush(struct bt_ctf_stream *stream);
%rename("_bt_ctf_stream_get") bt_ctf_stream_get(struct bt_ctf_stream *stream);
%rename("_bt_ctf_stream_put") bt_ctf_stream_put(struct bt_ctf_stream *stream);

struct bt_ctf_stream_class *bt_ctf_stream_class_create(const char *name);
int bt_ctf_stream_class_set_clock(struct bt_ctf_stream_class *stream_class, struct bt_ctf_clock *clock);
int bt_ctf_stream_class_add_event_class(struct bt_ctf_stream_class *stream_class, struct bt_ctf_event_class *event_class);
void bt_ctf_stream_class_get(struct bt_ctf_stream_class *stream_class);
void bt_ctf_stream_class_put(struct bt_ctf_stream_class *stream_class);
void bt_ctf_stream_append_discarded_events(struct bt_ctf_stream *stream, uint64_t event_count);
int bt_ctf_stream_append_event(struct bt_ctf_stream *stream, struct bt_ctf_event *event);
int bt_ctf_stream_flush(struct bt_ctf_stream *stream);
void bt_ctf_stream_get(struct bt_ctf_stream *stream);
void bt_ctf_stream_put(struct bt_ctf_stream *stream);

/* =================================================================
			WRITER.H
		¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*/
%rename("_bt_ctf_writer_create") bt_ctf_writer_create(const char *path);
%rename("_bt_ctf_writer_create_stream") bt_ctf_writer_create_stream(struct bt_ctf_writer *writer, struct bt_ctf_stream_class *stream_class);
%rename("_bt_ctf_writer_add_environment_field") bt_ctf_writer_add_environment_field(struct bt_ctf_writer *writer, const char *name, const char *value);
%rename("_bt_ctf_writer_add_clock") bt_ctf_writer_add_clock(struct bt_ctf_writer *writer, struct bt_ctf_clock *clock);
%newobject bt_ctf_writer_get_metadata_string;
%rename("_bt_ctf_writer_get_metadata_string") bt_ctf_writer_get_metadata_string(struct bt_ctf_writer *writer);
%rename("_bt_ctf_writer_flush_metadata") bt_ctf_writer_flush_metadata(struct bt_ctf_writer *writer);
%rename("_bt_ctf_writer_set_byte_order") bt_ctf_writer_set_byte_order(struct bt_ctf_writer *writer, enum bt_ctf_byte_order byte_order);
%rename("_bt_ctf_writer_get") bt_ctf_writer_get(struct bt_ctf_writer *writer);
%rename("_bt_ctf_writer_put") bt_ctf_writer_put(struct bt_ctf_writer *writer);

struct bt_ctf_writer *bt_ctf_writer_create(const char *path);
struct bt_ctf_stream *bt_ctf_writer_create_stream(struct bt_ctf_writer *writer, struct bt_ctf_stream_class *stream_class);
int bt_ctf_writer_add_environment_field(struct bt_ctf_writer *writer, const char *name, const char *value);
int bt_ctf_writer_add_clock(struct bt_ctf_writer *writer, struct bt_ctf_clock *clock);
char *bt_ctf_writer_get_metadata_string(struct bt_ctf_writer *writer);
void bt_ctf_writer_flush_metadata(struct bt_ctf_writer *writer);
int bt_ctf_writer_set_byte_order(struct bt_ctf_writer *writer, enum bt_ctf_byte_order byte_order);
void bt_ctf_writer_get(struct bt_ctf_writer *writer);
void bt_ctf_writer_put(struct bt_ctf_writer *writer);

%pythoncode %{

class CTFWriter:

	class Clock:
		def __init__(self, name):
			self._c = _bt_ctf_clock_create(name)
			if self._c is None:
				raise ValueError("Invalid clock name.")

		def __del__(self):
			_bt_ctf_clock_put(self._c)

		"""
		Get the clock's description.
		"""
		@property
		def description(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set the clock's description. The description appears in the clock's TSDL
		meta-data.
		"""
		@description.setter
		def description(self, desc):
			ret = _bt_ctf_clock_set_description(self._c, str(desc))
			if ret < 0:
				raise ValueError("Invalid clock description.")

		"""
		Get the clock's frequency (Hz).
		"""
		@property
		def frequency(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set the clock's frequency (Hz).
		"""
		@frequency.setter
		def frequency(self, freq):
			ret = _bt_ctf_clock_set_frequency(self._c, freq)
			if ret < 0:
				raise ValueError("Invalid frequency value.")

		"""
		Get the clock's precision (in clock ticks).
		"""
		@property
		def precision(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set the clock's precision (in clock ticks).
		"""
		@precision.setter
		def precision(self, precision):
			ret = _bt_ctf_clock_set_precision(self._c, precision)

		"""
		Get the clock's offset in seconds from POSIX.1 Epoch.
		"""
		@property
		def offset_seconds(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set the clock's offset in seconds from POSIX.1 Epoch.
		"""
		@offset_seconds.setter
		def offset_seconds(self, offset_s):
			ret = _bt_ctf_clock_set_offset_s(self._c, offset_s)
			if ret < 0:
				raise ValueError("Invalid offset value.")

		"""
		Get the clock's offset in ticks from POSIX.1 Epoch + offset in seconds.
		"""
		@property
		def offset(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set the clock's offset in ticks from POSIX.1 Epoch + offset in seconds.
		"""
		@offset.setter
		def offset(self, offset):
			ret = _bt_ctf_clock_set_offset(self._c, offset)
			if ret < 0:
				raise ValueError("Invalid offset value.")

		"""
		Get a clock's absolute attribute. A clock is absolute if the clock
		is a global reference across the trace's other clocks.
		"""
		@property
		def absolute(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set a clock's absolute attribute. A clock is absolute if the clock
		is a global reference across the trace's other clocks.
		"""
		@absolute.setter
		def absolute(self, is_absolute):
			ret = _bt_ctf_clock_set_is_absolute(self._c, int(is_absolute))
			if ret < 0:
				raise ValueError("Could not set the clock's absolute attribute.")

		"""
		Get the current time in nanoseconds since the clock's origin (offset and
		offset_s attributes).
		"""
		@property
		def time(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set the current time in nanoseconds since the clock's origin (offset and
		offset_s attributes). The clock's value will be sampled as events are
		appended to a stream.
		"""
		@time.setter
		def time(self, time):
			ret = _bt_ctf_clock_set_time(self._c, time)
			if ret < 0:
				raise ValueError("Invalid time value.")

	class FieldDeclaration:
		"""
		FieldDeclaration should not be instantiated directly. Please instantiate
		one of the concrete FieldDeclaration classes.
		"""
		class IntegerBase:
			# These values are based on the bt_ctf_integer_base enum
			# declared in event-types.h.
			INTEGER_BASE_UNKNOWN = -1
			INTEGER_BASE_BINARY = 2
			INTEGER_BASE_OCTAL = 8
			INTEGER_BASE_DECIMAL = 10
			INTEGER_BASE_HEXADECIMAL = 16

		def __init__(self):
			if self._ft is None:
				raise ValueError("FieldDeclaration creation failed.")

		def __del__(self):
			_bt_ctf_field_type_put(self._ft)

		"""
		Get the field type's alignment.
		"""
		@property
		def alignment(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set the field type's alignment. Defaults to 1 (bit-aligned). However,
		some types, such as structures and string, may impose other alignment
		constraints.
		"""
		@alignment.setter
		def alignment(self, alignment):
			ret = _bt_ctf_field_type_set_alignment(self._ft, alignment)
			if ret < 0:
				raise ValueError("Invalid alignment value.")

		"""
		Get the field type's byte order. One of the ByteOrder's constant.
		"""
		@property
		def byte_order(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set the field type's byte order. Use constants defined in the ByteOrder
		class.
		"""
		@byte_order.setter
		def byte_order(self, byte_order):
			ret = _bt_ctf_field_type_set_byte_order(self._ft, byte_order)
			if ret < 0:
				raise ValueError("Could not set byte order value.")

	class IntegerFieldDeclaration(FieldDeclaration):
		"""
		Create a new integer field type of the given size.
		"""
		def __init__(self, size):
			self._ft = _bt_ctf_field_type_integer_create(size)
			super().__init__()

		"""
		Get an integer's signedness attribute.
		"""
		@property
		def signed(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set an integer's signedness attribute.
		"""
		@signed.setter
		def signed(self, signed):
			ret = _bt_ctf_field_type_integer_set_signed(self._ft, signed)
			if ret < 0:
				raise ValueError("Could not set signed attribute.")

		"""
		Get the integer's base used to pretty-print the resulting trace.
		"""
		@property
		def base(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set the integer's base used to pretty-print the resulting trace.
		The base must be a constant of the IntegerBase class.
		"""
		@base.setter
		def base(self, base):
			ret = _bt_ctf_field_type_integer_set_base(self._ft, base)
			if ret < 0:
				raise ValueError("Could not set base value.")

		"""
		Get the integer's encoding (one of the constants of the
		CTFStringEncoding class).
		"""
		@property
		def encoding(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		An integer encoding may be set to signal that the integer must be printed
		as a text character. Must be a constant from the CTFStringEncoding class.
		"""
		@encoding.setter
		def encoding(self, encoding):
			ret = _bt_ctf_field_type_integer_set_encoding(self._ft, encoding)
			if ret < 0:
				raise ValueError("Could not set integer encoding.")

	class EnumerationFieldDeclaration(FieldDeclaration):
		"""
		Create a new enumeration field type with the given underlying type.
		"""
		def __init__(self, integer_type):
			if integer_type is None or not isinstance(integer_type, CTFWriter.IntegerFieldDeclaration):
				raise TypeError("Invalid integer container.")

			self._ft = _bt_ctf_field_type_enumeration_create(integer_type._ft)
			super().__init__()

		"""
		Add a mapping to the enumeration. The range's values are inclusive.
		"""
		def add_mapping(self, name, range_start, range_end):
			ret = _bt_ctf_field_type_enumeration_add_mapping(self._ft, str(name), range_start, range_end)
			if ret < 0:
				raise ValueError("Could not add mapping to enumeration type.")

	class FloatFieldDeclaration(FieldDeclaration):
		FLT_EXP_DIG = 8
		DBL_EXP_DIG = 11
		FLT_MANT_DIG = 24
		DBL_MANT_DIG = 53

		"""
		Create a new floating point field type.
		"""
		def __init__(self):
			self._ft = _bt_ctf_field_type_floating_point_create()
			super().__init__()

		"""
		Get the number of exponent digits to use to store the floating point field.
		"""
		@property
		def exponent_digits(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set the number of exponent digits to use to store the floating point field.
		The only values currently supported are FLT_EXP_DIG and DBL_EXP_DIG which
		are defined as constants of this class.
		"""
		@exponent_digits.setter
		def exponent_digits(self, exponent_digits):
			ret = _bt_ctf_field_type_floating_point_set_exponent_digits(self._ft, exponent_digits)
			if ret < 0:
				raise ValueError("Could not set exponent digit count.")

		"""
		Get the number of mantissa digits to use to store the floating point field.
		"""
		@property
		def mantissa_digits(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set the number of mantissa digits to use to store the floating point field.
		The only values currently supported are FLT_MANT_DIG and DBL_MANT_DIG which
		are defined as constants of this class.
		"""
		@mantissa_digits.setter
		def mantissa_digits(self, mantissa_digits):
			ret = _bt_ctf_field_type_floating_point_set_mantissa_digits(self._ft, mantissa_digits)
			if ret < 0:
				raise ValueError("Could not set mantissa digit count.")

	class StructureFieldDeclaration(FieldDeclaration):
		"""
		Create a new structure field type.
		"""
		def __init__(self):
			self._ft = _bt_ctf_field_type_structure_create()
			super().__init__()

		"""
		Add a field of type "field_type" to the structure.
		"""
		def add_field(self, field_type, field_name):
			ret = _bt_ctf_field_type_structure_add_field(self._ft, field_type._ft, str(field_name))
			if ret < 0:
				raise ValueError("Could not add field to structure.")

	class VariantFieldDeclaration(FieldDeclaration):
		"""
		Create a new variant field type.
		"""
		def __init__(self, enum_tag, tag_name):
			if enum_tag is None or not isinstance(enum_tag, CTFWriter.EnumerationFieldDeclaration):
				raise TypeError("Invalid tag type; must be of type EnumerationFieldDeclaration.")

			self._ft = _bt_ctf_field_type_variant_create(enum_tag._ft, str(tag_name))
			super().__init__()

		"""
		Add a field of type "field_type" to the variant.
		"""
		def add_field(self, field_type, field_name):
			ret = _bt_ctf_field_type_variant_add_field(self._ft, field_type._ft, str(field_name))
			if ret < 0:
				raise ValueError("Could not add field to variant.")

	class ArrayFieldDeclaration(FieldDeclaration):
		"""
		Create a new array field type.
		"""
		def __init__(self, element_type, length):
			self._ft = _bt_ctf_field_type_array_create(element_type._ft, length)
			super().__init__()

	class SequenceFieldDeclaration(FieldDeclaration):
		"""
		Create a new sequence field type.
		"""
		def __init__(self, element_type, length_field_name):
			self._ft = _bt_ctf_field_type_sequence_create(element_type._ft, str(length_field_name))
			super().__init__()

	class StringFieldDeclaration(FieldDeclaration):
		"""
		Create a new string field type.
		"""
		def __init__(self):
			self._ft = _bt_ctf_field_type_string_create()
			super().__init__()

		"""
		Get a string type's encoding (a constant from the CTFStringEncoding class).
		"""
		@property
		def encoding(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set a string type's encoding. Must be a constant from the CTFStringEncoding class.
		"""
		@encoding.setter
		def encoding(self, encoding):
			ret = _bt_ctf_field_type_string_set_encoding(self._ft, encoding)
			if ret < 0:
				raise ValueError("Could not set string encoding.")

	"""
	Create an instance of a field.
	"""
	@staticmethod
	def create_field(self, field_type):
		if field_type is None or not isinstance(field_type, CTFWriter.FieldDeclaration):
			raise TypeError("Invalid field_type. Type must be a FieldDeclaration-derived class.")

		if isinstance(field_type, CTFWriter.IntegerFieldDeclaration):
			return CTFWriter.IntegerField(field_type)
		elif isinstance(field_type, CTFWriter.EnumerationFieldDeclaration):
			return CTFWriter.EnumerationField(field_type)
		elif isinstance(field_type, CTFWriter.FloatFieldDeclaration):
			return CTFWriter.FloatFieldingPoint(field_type)
		elif isinstance(field_type, CTFWriter.StructureFieldDeclaration):
			return CTFWriter.StructureField(field_type)
		elif isinstance(field_type, CTFWriter.VariantFieldDeclaration):
			return CTFWriter.VariantField(field_type)
		elif isinstance(field_type, CTFWriter.ArrayFieldDeclaration):
			return CTFWriter.ArrayField(field_type)
		elif isinstance(field_type, CTFWriter.SequenceFieldDeclaration):
			return CTFWriter.SequenceField(field_type)
		elif isinstance(field_type, CTFWriter.StringFieldDeclaration):
			return CTFWriter.StringField(field_type)

	class Field:
		"""
		Base class, do not instantiate.
		"""
		def __init__(self, field_type):
			if not isinstance(field_type, CTFWriter.FieldDeclaration):
				raise TypeError("Invalid field_type argument.")

			self._f = _bt_ctf_field_create(field_type._ft)
			if self._f is None:
				raise ValueError("Field creation failed.")

		def __del__(self):
			_bt_ctf_field_put(self._f)

		@staticmethod
		def _create_field_from_native_instance(native_field_instance):
			type_dict = {
				CTFTypeId.INTEGER : CTFWriter.IntegerField,
				CTFTypeId.FLOAT : CTFWriter.FloatFieldingPoint,
				CTFTypeId.ENUM : CTFWriter.EnumerationField,
				CTFTypeId.STRING : CTFWriter.StringField,
				CTFTypeId.STRUCT : CTFWriter.StructureField,
				CTFTypeId.VARIANT : CTFWriter.VariantField,
				CTFTypeId.ARRAY : CTFWriter.ArrayField,
				CTFTypeId.SEQUENCE : CTFWriter.SequenceField
			}

			field_type = _bt_python_get_field_type(native_field_instance)
			if field_type == CTFTypeId.UNKNOWN:
				raise TypeError("Invalid field instance")

			field = CTFWriter.Field.__new__(CTFWriter.Field)
			field._f = native_field_instance
			field.__class__ = type_dict[field_type]
			return field

	class IntegerField(Field):
		"""
		Get an integer field's value.
		"""
		@property
		def value(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set an integer field's value.
		"""
		@value.setter
		def value(self, value):
			signedness = _bt_python_field_integer_get_signedness(self._f)
			if signedness < 0:
				raise TypeError("Invalid integer instance.")

			if signedness == 0:
				ret = _bt_ctf_field_unsigned_integer_set_value(self._f, value)
			else:
				ret = _bt_ctf_field_signed_integer_set_value(self._f, value)

			if ret < 0:
				raise ValueError("Could not set integer field value.")

	class EnumerationField(Field):
		"""
		Return the enumeration's underlying container field (an integer field).
		"""
		@property
		def container(self):
			container = CTFWriter.IntegerField.__new__(CTFWriter.IntegerField)
			container._f = _bt_ctf_field_enumeration_get_container(self._f)
			if container._f is None:
				raise TypeError("Invalid enumeration field type.")
			return container

	class FloatFieldingPoint(Field):
		"""
		Get a floating point field's value.
		"""
		@property
		def value(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set a floating point field's value.
		"""
		@value.setter
		def value(self, value):
			ret = _bt_ctf_field_floating_point_set_value(self._f, float(value))
			if ret < 0:
				raise ValueError("Could not set floating point field value.")

	class StructureField(Field):
		"""
		Get the structure's field corresponding to the provided field name.
		"""
		def field(self, field_name):
			native_instance = _bt_ctf_field_structure_get_field(self._f, str(field_name))
			if native_instance is None:
				raise ValueError("Invalid field_name provided.")
			return CTFWriter.Field._create_field_from_native_instance(native_instance)

	class VariantField(Field):
		"""
		Return the variant's selected field. The "tag" field is the selector enum field.
		"""
		def field(self, tag):
			native_instance = _bt_ctf_field_variant_get_field(self._f, tag._f)
			if native_instance is None:
				raise ValueError("Invalid tag provided.")
			return CTFWriter.Field._create_field_from_native_instance(native_instance)

	class ArrayField(Field):
		"""
		Return the array's field at position "index".
		"""
		def field(self, index):
			native_instance = _bt_ctf_field_array_get_field(self._f, index)
			if native_instance is None:
				raise IndexError("Invalid index provided.")
			return CTFWriter.Field._create_field_from_native_instance(native_instance)

	class SequenceField(Field):
		"""
		Get the sequence's length field (IntegerField).
		"""
		@property
		def length(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set the sequence's length field (IntegerField).
		"""
		@length.setter
		def length(self, length_field):
			if not isinstance(length_field, CTFWriter.IntegerField):
				raise TypeError("Invalid length field.")
			ret = _bt_ctf_field_sequence_set_length(self._f, length_field._f)
			if ret < 0:
				raise ValueError("Could not set sequence length.")

		"""
		Return the sequence's field at position "index".
		"""
		def field(self, index):
			native_instance = _bt_ctf_field_sequence_get_field(self._f, index)
			if native_instance is None:
				raise ValueError("Could not get sequence element at index.")
			return CTFWriter.Field._create_field_from_native_instance(native_instance)

	class StringField(Field):
		"""
		Get a string field's value.
		"""
		@property
		def value(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set a string field's value.
		"""
		@value.setter
		def value(self, value):
			ret = _bt_ctf_field_string_set_value(self._f, str(value))
			if ret < 0:
				raise ValueError("Could not set string field value.")

	class EventClass:
		"""
		Create a new event class of the given name.
		"""
		def __init__(self, name):
			self._ec = _bt_ctf_event_class_create(name)
			if self._ec is None:
				raise ValueError("Event class creation failed.")

		def __del__(self):
			_bt_ctf_event_class_put(self._ec)

		"""
		Add a field of type "field_type" to the event class.
		"""
		def add_field(self, field_type, field_name):
			ret = _bt_ctf_event_class_add_field(self._ec, field_type._ft, str(field_name))
			if ret < 0:
				raise ValueError("Could not add field to event class.")

	class Event:
		"""
		Create a new event of the given event class.
		"""
		def __init__(self, event_class):
			if not isinstance(event_class, CTFWriter.EventClass):
				raise TypeError("Invalid event_class argument.")

			self._e = _bt_ctf_event_create(event_class._ec)
			if self._e is None:
				raise ValueError("Event creation failed.")

		def __del__(self):
			_bt_ctf_event_put(self._e)

		"""
		Set a manually created field as an event's payload.
		"""
		def set_payload(self, field_name, value_field):
			if not isinstance(value, CTFWriter.Field):
				raise TypeError("Invalid value type.")
			ret = _bt_ctf_event_set_payload(self._e, str(field_name), value_field._f)
			if ret < 0:
				raise ValueError("Could not set event field payload.")

		"""
		Get a field from event.
		"""
		def payload(self, field_name):
			native_instance = _bt_ctf_event_get_payload(self._e, str(field_name))
			if native_instance is None:
				raise ValueError("Could not get event payload.")
			return CTFWriter.Field._create_field_from_native_instance(native_instance)

	class StreamClass:
		"""
		Create a new stream class of the given name.
		"""
		def __init__(self, name):
			self._sc = _bt_ctf_stream_class_create(name)
			if self._sc is None:
				raise ValueError("Stream class creation failed.")

		def __del__(self):
			_bt_ctf_stream_class_put(self._sc)

		"""
		Get a stream class' clock.
		"""
		@property
		def clock(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Assign a clock to a stream class.
		"""
		@clock.setter
		def clock(self, clock):
			if not isinstance(clock, CTFWriter.Clock):
				raise TypeError("Invalid clock type.")

			ret = _bt_ctf_stream_class_set_clock(self._sc, clock._c)
			if ret < 0:
				raise ValueError("Could not set stream class clock.")

		"""
		Add an event class to a stream class. New events can be added even after a
		stream has been instantiated and events have been appended. However, a stream
		will not accept events of a class that has not been registered beforehand.
		"""
		def add_event_class(self, event_class):
			if not isinstance(event_class, CTFWriter.EventClass):
				raise TypeError("Invalid event_class type.")

			ret = _bt_ctf_stream_class_add_event_class(self._sc, event_class._ec)
			if ret < 0:
				raise ValueError("Could not add event class.")

	class Stream:
		"""
		Create a stream of the given class.
		"""
		def __init__(self, stream_class):
			if not isinstance(stream_class, CTFWriter.StreamClass):
				raise TypeError("Invalid stream_class type.")

			self._s = _bt_ctf_stream_create(stream_class._sc)
			if self._s is None:
				raise ValueError("Stream creation failed.")

		def __del__(self):
			_bt_ctf_stream_put(self._s)

		"""
		Increase the current packet's discarded event count.
		"""
		def append_discarded_events(self, event_count):
			_bt_ctf_stream_append_discarded_events(self._s, event_count)

		"""
		Append "event" to the stream's current packet. The stream's associated clock
		will be sampled during this call. The event shall not be modified after
		being appended to a stream.
		"""
		def append_event(self, event):
			ret = _bt_ctf_stream_append_event(self._s, event._e)
			if ret < 0:
				raise ValueError("Could not append event to stream.")

		"""
		The stream's current packet's events will be flushed to disk. Events
		subsequently appended to the stream will be added to a new packet.
		"""
		def flush(self):
			ret = _bt_ctf_stream_flush(self._s)
			if ret < 0:
				raise ValueError("Could not flush stream.")

	class Writer:
		"""
		Create a new writer that will produce a trace in the given path.
		"""
		def __init__(self, path):
			self._w = _bt_ctf_writer_create(path)
			if self._w is None:
				raise ValueError("Writer creation failed.")

		def __del__(self):
			_bt_ctf_writer_put(self._w)

		"""
		Create a new stream instance and register it to the writer.
		"""
		def create_stream(self, stream_class):
			if not isinstance(stream_class, CTFWriter.StreamClass):
				raise TypeError("Invalid stream_class type.")

			stream = CTFWriter.Stream.__new__(CTFWriter.Stream)
			stream._s = _bt_ctf_writer_create_stream(self._w, stream_class._sc)
			return stream

		"""
		Add an environment field to the trace.
		"""
		def add_environment_field(self, name, value):
			ret = _bt_ctf_writer_add_environment_field(self._w, str(name), str(value))
			if ret < 0:
				raise ValueError("Could not add environment field to trace.")

		"""
		Add a clock to the trace. Clocks assigned to stream classes must be
		registered to the writer.
		"""
		def add_clock(self, clock):
			ret = _bt_ctf_writer_add_clock(self._w, clock._c)
			if ret < 0:
				raise ValueError("Could not add clock to Writer.")

		"""
		Get the trace's TSDL meta-data.
		"""
		@property
		def metadata(self):
			return _bt_ctf_writer_get_metadata_string(self._w)

		"""
		Flush the trace's metadata to the metadata file.
		"""
		def flush_metadata(self):
			_bt_ctf_writer_flush_metadata(self._w)

		"""
		Get the trace's byte order. Must be a constant from the ByteOrder
		class.
		"""
		@property
		def byte_order(self):
			raise NotImplementedError("Getter not implemented.")

		"""
		Set the trace's byte order. Must be a constant from the ByteOrder
		class. Defaults to BYTE_ORDER_NATIVE, the host machine's endianness.
		"""
		@byte_order.setter
		def byte_order(self, byte_order):
			ret = _bt_ctf_writer_set_byte_order(self._w, byte_order)
			if ret < 0:
				raise ValueError("Could not set trace's byte order.")

%}
